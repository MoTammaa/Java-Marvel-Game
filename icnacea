public void move(Direction d) throws UnallowedMovementException, NotEnoughResourcesException{
		if(this.getCurrentChampion().getCondition() == Condition.ROOTED)
			throw new UnallowedMovementException("The champion is rooted.");
		
		if(this.getCurrentChampion().getCurrentActionPoints() < 1)
			throw new NotEnoughResourcesException("Not enough action points.");
		Point l = this.getCurrentChampion().getLocation();
		switch(d){
		case RIGHT: 
			if(this.getCurrentChampion().getLocation().y < BOARDWIDTH-1){
				if(board[l.x][l.y+1] == null){
					board[l.x][l.y+1] = this.getCurrentChampion();
					board[l.x][l.y] = null;
					this.getCurrentChampion().setLocation(new Point(l.x, l.y+1));
					}
				else
					throw new UnallowedMovementException("This is an invlaid movement");
				}
			else
				throw new UnallowedMovementException("This is an invlaid movement");
			break;
		
		case LEFT: 
			if(this.getCurrentChampion().getLocation().y > 0){
				if(board[l.x][l.y-1] == null){
					board[l.x][l.y-1] = this.getCurrentChampion();
					board[l.x][l.y] = null;
					this.getCurrentChampion().setLocation(new Point(l.x, l.y-1));
					}
				else
					throw new UnallowedMovementException("This is an invlaid movement");
				}
			else
				throw new UnallowedMovementException("This is an invlaid movement");
			break;
		
		case DOWN: 
			if(l.x > 0){
				if(board[l.x-1][l.y] == null){
					board[l.x-1][l.y] = this.getCurrentChampion();
					board[l.x][l.y] = null;
					this.getCurrentChampion().setLocation(new Point(l.x-1, l.y));
					}
				else
					throw new UnallowedMovementException("This is an invlaid movement");
				}
			else
				throw new UnallowedMovementException("This is an invlaid movement");
			break;
		
		case UP: 
			if(l.x < BOARDWIDTH-1){
				if(l.x >= 0){
					if(board[l.x+1][l.y] == null){
						board[l.x+1][l.y] = this.getCurrentChampion();
						board[l.x][l.y] = null;
						this.getCurrentChampion().setLocation(new Point(l.x+1, l.y));
						}
				else
					throw new UnallowedMovementException("This is an invlaid movement");
				}
			else
				throw new UnallowedMovementException("This is an invlaid movement");
			break;
			}
		this.getCurrentChampion().setCurrentActionPoints(this.getCurrentChampion().getCurrentActionPoints()-1);
		}
	}

	public void castAbility(Ability a, Direction d) throws AbilityUseException, NotEnoughResourcesException, CloneNotSupportedException{
		if(a.getCastArea() != AreaOfEffect.DIRECTIONAL)
			return;
		for(int i=0; i<this.getCurrentChampion().getAppliedEffects().size(); i++)
			if(this.getCurrentChampion().getAppliedEffects().get(i) instanceof Silence)
				throw new AbilityUseException("Champion is silenced. You can't use the Ability.");
		
		if(this.getCurrentChampion().getMana() < a.getManaCost())
			throw new NotEnoughResourcesException("Not enough mana for casting this Ability.");
		if(this.getCurrentChampion().getCurrentActionPoints() < a.getRequiredActionPoints())
			throw new NotEnoughResourcesException("Not enough mana for casting this Ability.");
		if(a.getCurrentCooldown() != 0){
			throw new NotEnoughResourcesException("This ability is on cooldown.");
		}
		
		ArrayList<Damageable> targets = new ArrayList<>();
		
		switch(d){
		
		case RIGHT:
			for(int i = 1; i <= a.getCastRange() && this.getCurrentChampion().getLocation().y+i < BOARDHEIGHT; i++){
				if(board[this.getCurrentChampion().getLocation().x][this.getCurrentChampion().getLocation().y+i] != null){
					targets.add((Damageable) board[this.getCurrentChampion().getLocation().x][this.getCurrentChampion().getLocation().y+i]);
					}
				}
			break;
		
			case LEFT:
				for(int i = 1; i <= a.getCastRange() && this.getCurrentChampion().getLocation().y-i >= 0; i++){
					if(board[this.getCurrentChampion().getLocation().x][this.getCurrentChampion().getLocation().y-i] != null){
						targets.add((Damageable) board[this.getCurrentChampion().getLocation().x][this.getCurrentChampion().getLocation().y-i]);
					}
				}
				break;
				
			case DOWN:
				for(int i = 1; i <=  a.getCastRange() && this.getCurrentChampion().getLocation().x-i >= 0; i++){
					if(board[this.getCurrentChampion().getLocation().x-i][this.getCurrentChampion().getLocation().y] != null){
						targets.add((Damageable) board[this.getCurrentChampion().getLocation().x-i][this.getCurrentChampion().getLocation().y]);
					}
				}
				break;
				
			case UP:
				for(int i = 1; i <=  a.getCastRange() && this.getCurrentChampion().getLocation().x+i < BOARDWIDTH; i++){
					if(board[this.getCurrentChampion().getLocation().x+i][this.getCurrentChampion().getLocation().y] != null){
						targets.add((Damageable) board[this.getCurrentChampion().getLocation().x+i][this.getCurrentChampion().getLocation().y]);
					}	
				}
				break;
		}
		Player current = null;
		if(firstPlayer.getTeam().contains(this.getCurrentChampion())){
			current = firstPlayer;
		}
		else{
			current = secondPlayer;
		}
		
		ArrayList<Damageable> allies = new ArrayList<>();
		ArrayList<Damageable> enemies = new ArrayList<>();
		ArrayList<Damageable> covers = new ArrayList<>();
		for(int i= 0; i<targets.size(); i++){
			if(targets.get(i) instanceof Cover)
				covers.add(targets.get(i));	
			else{
				if(current.getTeam().contains(targets.get(i)))
					allies.add(targets.get(i));
				else
					enemies.add(targets.get(i));
			}
		}
		if (targets.size() != 0) {
			if (a instanceof CrowdControlAbility)
				if (((CrowdControlAbility) a).getEffect().getType() == EffectType.DEBUFF)
					a.execute(enemies);
				else
					a.execute(allies);

			if (a instanceof DamagingAbility) {
				a.execute(enemies);
				a.execute(covers);
			} else if (a instanceof HealingAbility)
				a.execute(allies);
			for(int i= 0; i<targets.size(); i++){
				if(targets.get(i).getCurrentHP()==0)
				{
					board[targets.get(i).getLocation().x][targets.get(i).getLocation().y] = null;
				    if(targets.get(i) instanceof Champion)
				    {
				    	((Champion)targets.get(i)).setLocation(null);
				    	((Champion)targets.get(i)).setCondition(Condition.KNOCKEDOUT);
				    }
				}
			
			}
		}
